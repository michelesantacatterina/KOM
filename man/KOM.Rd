% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/KOM.R
\name{KOM}
\alias{KOM}
\title{Optimal Estimation of Generalized Average Treatment Effects using Kernel Optimal Matching}
\usage{
KOM(outcome, intervention, confounders, sample_population = rep(1,
  length(outcome)), gpml = "Python", kernel = c("poly"),
  degree = c(1), operator = "single", scale = c(TRUE, TRUE),
  estimand = c("SATE"), penal = c(1), weights = rep(1,
  length(outcome)), truncation_level = c(0.9), Presolve = c(2),
  OutputFlag = c(0), python_path = "~/anaconda3/bin/python")
}
\arguments{
\item{outcome}{outcome under study.}

\item{intervention}{binary intervention/treatment.}

\item{confounders}{a matrix containing all confounders. Each column represents a confounder.}

\item{sample_population}{vector containing information about the sample population. When \code{estimand="TATE"} (see below, parameter \code{estimand}) is the estimand of interest, \code{sample_population=rep(1,n)} is the sample,
\code{sample_population=rep(0,nt)} is the target population of interest where nt is the sample size in the target population.}

\item{gpml}{specifies the method for Gaussian Process Maximum Likelihood for tuning the hyperparameters. Choices are \code{R} and \code{Python}. Default \code{gpml="Python"}.}

\item{kernel}{specifies the kernel to be used, choices are #' \enumerate{ \item for \code{gpml="R"}: "poly" (polynomial kernel), "rbf" (rbf kernel). Default "poly".
\item for \code{gpml="Python"}: "poly" (polynomial kernel), "rbf" (rbf kernel), "matern1.5" (Matern kernel with nu=1.5), and "matern2.5" (Matern kernel with nu=2.5).}
Default \code{kernel="poly"}.}

\item{degree}{degree of the polynomial kernel, e.g., 1=linear, 2=quadratic, 3=cubic. Default \code{degree=c(1)}.}

\item{operator}{kernel(s)' operator, choices are \code{single}, \code{sum} and \code{prod}. If \code{sum} or \code{prod} is chosen, please provide a vector of kernels and degrees for the
parameters \code{kernel} and \code{degree} respectively, e.g., \code{operator="prod"}, then set \code{kernel=c("poly","poly")}, \code{degree=c(2,2)} for a product of polynomial degree 2 kernels.}

\item{scale}{center and scale parameters for scaling/centering covariates. First parameter is center, second parameter is scale. Default \code{scale=c(TRUE,TRUE)}.}

\item{estimand}{the estimand of interest, choices are between SATE, KOWATE, KOSATE, and TATE. Default \code{estimand="SATE"}.}

\item{penal}{penalization parameter for the variance of the estimator, \eqn{\lambda}. Default \code{penal=1} - optimal, i.e., \eqn{\gamma^2/\sigma^2}.}

\item{weights}{weights V in the main manuscript. Then we compute SATE in a population pre-specified by a set of weights. For example truncated or overlap weights. In other words,
we want to compute the set of weights that minimize the conditional mean square error of the weighted estimator for SATE in a population defined by the pre-specified weights.
If a set of weights all equal to 1 is provided, we estimate SATE in the sample population. Default \code{weights=rep(1,length(outcome)}, where n is the sample size.}

\item{truncation_level}{truncation level for computing KOSATE. Default \code{truncation_level=c(0.9)}.}

\item{Presolve}{presolve parameter for gurobi optimizer. More info \href{https://www.gurobi.com/documentation/8.1/refman/presolve.html}{here}. Default \code{Presolve=c(2)} - aggressive.}

\item{OutputFlag}{enables or disables solver output. More info \href{https://www.gurobi.com/documentation/8.1/refman/outoutflag.html}{here}. Default \code{OutputFlag=c(0)}.}

\item{python_path}{python path. Default \code{python_path = "~/anaconda3/bin/python"}.}
}
\value{
A list the following.
\item{res}{\code{gurobi} type object}
\item{WV}{combined vector of weights W and V size 2*n solution to the optimization problem, when \code{estimand="KOWATE" or "KOSATE"}}
\item{W}{vector of weights W size n solution to the optimization problem.}
\item{V}{vector of weights V size n solution to the optimization problem when \code{estimand="KOWATE" or "KOSATE"}.}
\item{res.optim2_1_par}{vector of tuned hyperparameters for treated. The first is \eqn{\gamma^2}, the hyperparameter that controls the overall scale of the kernel.
The last is \eqn{\gamma^2}, the Gaussian Process variance. The remaining hyperparameters are kernel specific. For example, for polynomial kernels, \eqn{\sigma}
controls the importance of higher orders degrees. These hyperparameters are not of direct interest of the user, they are only used to compute the Gram matrices.}
\item{res.optim2_0_par}{vector of tuned hyperparameters for controls. Same info as for the treated hyperparameters.}
\item{sigma0}{Gaussian Process variance \eqn{\gamma^2} for controls.}
\item{sigma1}{Gaussian Process variance \eqn{\gamma^2} for treated.}
\item{system_time_GPML0}{return CPU (and other) times for gpml among controls.}
\item{system_time_GPML1}{return CPU (and other) times for gpml among treated.}
\item{system_time_gurobi}{return CPU (and other) times for gurobi.}
\item{system_time_matrices}{return CPU (and other) times for building the matrices.}
\item{status}{return 1 if no errors are encountered, 0 otherwise.}
}
\description{
\code{KOM} estimates weights that minimize the worst-case Conditional Mean Squared Error (CMSE) of the weighted
estimator in estimating Generalized Average Treatment Effects (GATE) over the space of weights. The manuscript
can be found here: \href{https://arxiv.org/pdf/1908.04748.pdf}{https://arxiv.org/pdf/1908.04748.pdf}.
}
\details{
We highly suggest to use \code{Python} and \code{Gurobi} for \code{KOM}. To install \code{Python}, please install
\href{https://www.anaconda.com/distribution/}{Anaconda}. Once Anaconda is installed please install \code{sklearn} if not already installed.
To install the \code{R} interface of \code{Gurobi} please follow instructions
\href{https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation.html}{here}. \code{Gurobi} provides
\href{https://www.gurobi.com/downloads/end-user-license-agreement-academic/}{free academic licenses}
and \href{https://www.gurobi.com/downloads/eula-academic-online-course-license-request/}{free academic online course licenses}.
}
\examples{
\dontrun{
library(sandwich)

set.seed(1)

###########################################################################
#SATE and OWATE

#Data Generation
n             <- 300

X1            <- rnorm(n,0.1,1)
X2            <- rnorm(n,0.1,1)

dta           <- data.frame(X1,X2)
colnames(dta) <- c("X1","X2")

B             <- matrix(c(2,2),ncol=1)

prt           <- 1/(1+exp( -(dta$X1 + dta$X2) ))

Tr            <- rbinom(n,1,prt)
prop.table(table(Tr))

dta           <- data.frame(dta,Tr)
dta           <- dta[order(dta$Tr,decreasing=TRUE),]
colnames(dta) <- c("X1","X2","Tr")

effect_t      <- 2

B             <- matrix(c(2,2),ncol=1)

Y0            <- B[1]*dta$X1 + B[2]*dta$X2 + rnorm(n)
Y1            <- Y0 + effect_t
Y             <- Y0*(1-dta$Tr) + Y1*(dta$Tr)

dta           <- data.frame(Y,dta$X1,dta$X2,dta$Tr)
colnames(dta) <- c("Y","X1","X2","Tr")

Z             <- cbind(dta$X1,dta$X2)

colnames(Z)   <- c("Z1","Z2")
dta           <- data.frame(dta,Z)


#************************************
#Setup
confounders   <- cbind(dta$Z1,dta$Z2)
intervention  <- dta$Tr
outcome       <- dta$Y
kernel        <- c("poly")
degree        <- 1
penal         <- 1
operator      <- "single"


#************************************
#SATE
estimand      <- "SATE"

resultKOMSATE <- KOM(outcome,
                    intervention,
                    confounders,
                    kernel=kernel,
                    degree=degree,
                    operator=operator,
                    estimand=estimand)

summary(resultKOMSATE$W)
lmKOMSATE <- lm(Y~Tr,data=dta,weights=resultKOMSATE$W)
summary(lmKOMSATE)


#************************************
#KOWATE
estimand      <- "KOWATE"

resultKOWATE <- KOM(outcome,
                    intervention,
                    confounders,
                    kernel=kernel,
                    degree=degree,
                    operator=operator,
                    estimand=estimand)

summary(resultKOWATE$W)
lmKOWATE <- lm(Y~Tr,data=dta,weights=resultKOWATE$W)
summary(lmKOWATE)


#************************************
#KOSATE
estimand      <- "KOSATE"


resultKOSATE <- KOM(outcome,
                    intervention,
                    confounders,
                    kernel=kernel,
                    degree=degree,
                    operator=operator,
                    estimand=estimand)

summary(resultKOSATE$W)
lmKOSATE <- lm(Y~Tr,data=dta,weights=resultKOSATE$W)
summary(lmKOSATE)



#************************************
#SATE with fixed V - Overlap
estimand      <- "SATE"

#overlap weights
fit_tr        <- glm(Tr  ~ Z1 + Z2, data=dta, family="binomial")
pr1           <- fit_tr$fitted.values
overlap_w     <- dta$Tr*(1-pr1) + (1-dta$Tr)*pr1

resultSATE_O <- KOM(outcome,
                    intervention,
                    confounders,
                    kernel=kernel,
                    degree=degree,
                    operator=operator,
                    estimand=estimand,
                    weights=overlap_w)

summary(resultSATE_O$W)
lmSATE_O <- lm(Y~Tr,data=dta,weights=resultSATE_O$W)
summary(lmSATE_O)



#************************************
#SATE with fixed V - Truncated 0.1-0.9
estimand      <- "SATE"

#truncated weights
fit_tr        <- glm(Tr  ~ Z1 + Z2, data=dta, family="binomial")
pr1           <- fit_tr$fitted.values
overlap_w     <- dta$Tr*(1-pr1) + (1-dta$Tr)*pr1
indicator0109 <- (pr1>quantile(pr1,0.1))*(pr1<quantile(pr1,0.9))
truncated_ipw <- indicator0109*( dta$Tr/pr1 + (1-dta$Tr)/(1-pr1)  )
weights       <- truncated_ipw

resultSATE_T <- KOM(outcome,
                    intervention,
                    confounders,
                    kernel=kernel,
                    degree=degree,
                    operator=operator,
                    estimand=estimand,
                    weights=truncated_ipw)

summary(resultSATE_T$W)
lmSATE_T <- lm(Y~Tr,data=dta,weights=resultSATE_T$W)
summary(lmSATE_T)


#####'Compare results

summary(resultKOMSATE$W)
summary(resultKOWATE$W)
summary(resultSATE_O$W)
summary(resultSATE_T$W)
summary(resultKOSATE$W)

summary(lm(Y~Tr,data=dta))$coef[2]
summary(lmKOMSATE)$coef[2]
summary(lmKOWATE)$coef[2]
summary(lmKOSATE)$coef[2]
summary(lmSATE_O)$coef[2]
summary(lmSATE_T)$coef[2]

sqrt(diag(sandwich(lmKOMSATE)))[2]
sqrt(diag(sandwich(lmKOWATE)))[2]
sqrt(diag(sandwich(lmKOSATE)))[2]
sqrt(diag(sandwich(lmSATE_O)))[2]
sqrt(diag(sandwich(lmSATE_T)))[2]


}

}
\references{
Kallus, N., Santacatterina, M., "Optimal Estimation of Generalized Average
Treatment Effects using Kernel Optimal Matching", \url{https://arxiv.org/pdf/1908.04748.pdf}
}
\author{
Michele Santacatterina, \email{santacatterina@cornell.edu}
}
